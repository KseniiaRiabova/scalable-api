<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>API Performance Comparison Dashboard</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <link rel="shortcut icon" href="favicon.ico" />

    <link rel="stylesheet" href="comparison-dashboard.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  </head>
  <body>
    <!-- Header with social links -->
    <header class="dashboard-header">
      <div class="header-content">
        <div class="header-left">
          <span class="project-title">Scalable API Demo</span>
        </div>
        <div class="header-right">
          <a
            href="https://github.com/KseniiaRiabova/scalable-api"
            target="_blank"
            class="social-link"
            title="View Source Code"
          >
            <svg
              class="social-icon"
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path
                d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"
              />
            </svg>
          </a>
          <a
            href="https://www.linkedin.com/in/riabovakseniia/"
            target="_blank"
            class="social-link"
            title="Connect on LinkedIn"
          >
            <svg
              class="social-icon"
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path
                d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"
              />
            </svg>
          </a>
          <button
            class="info-button"
            onclick="showProjectInfo()"
            title="Learn More"
          >
            <svg
              class="info-icon"
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="currentColor"
            >
              <path
                d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"
              />
            </svg>
          </button>
        </div>
      </div>
    </header>

    <div class="container">
      <h1>API Performance Comparison Dashboard</h1>

      <!-- API Cards Section -->
      <div class="api-cards">
        <!-- Basic API Card -->
        <div class="api-card basic-api">
          <div class="api-title">
            <span class="status-indicator" id="basic-status"></span>
            üìç Basic API
          </div>
          <div class="api-description">
            Baseline performance<br />
            Simple database simulation<br />
            No caching, single process
          </div>
          <div class="api-metrics">
            <div class="metric-item">
              <span class="metric-label">Avg Response:</span>
              <span class="metric-value" id="basic-response">~1-5ms</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Total Time:</span>
              <span class="metric-value" id="basic-total-time">0s</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Throughput:</span>
              <span class="metric-value" id="basic-throughput">0 req/s</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Requests Count:</span>
              <span class="metric-value" id="basic-requests">0</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Cache Hit Rate:</span>
              <span class="metric-value">0%</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Workers:</span>
              <span class="metric-value">1</span>
            </div>
          </div>
          <button class="test-button" onclick="testBasicAPI()">
            Send 10 Requests
          </button>
          <button class="load-test-button" onclick="loadTestBasicAPI()">
            High Load Test (100 requests)
          </button>
          <button class="cpu-test-button" onclick="cpuTestBasicAPI()">
            üî• CPU Intensive Test
          </button>
        </div>

        <!-- Optimized API Card -->
        <div class="api-card optimized-api">
          <div class="api-title">
            <span class="status-indicator" id="optimized-status"></span>
            ‚ö° Optimized API
          </div>
          <div class="api-description">
            Redis caching enabled<br />
            Cache miss fallback to DB<br />
            Single process optimization
          </div>
          <div class="api-metrics">
            <div class="metric-item">
              <span class="metric-label">Avg Response:</span>
              <span class="metric-value" id="optimized-response">~1ms</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Total Time:</span>
              <span class="metric-value" id="optimized-total-time">0s</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Throughput:</span>
              <span class="metric-value" id="optimized-throughput"
                >0 req/s</span
              >
            </div>
            <div class="metric-item">
              <span class="metric-label">Requests Count:</span>
              <span class="metric-value" id="optimized-requests">0</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Cache Hit Rate:</span>
              <span class="metric-value" id="optimized-cache-rate">95%+</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Workers:</span>
              <span class="metric-value">1</span>
            </div>
          </div>
          <button class="test-button" onclick="testOptimizedAPI()">
            Send 10 Requests
          </button>
          <button class="load-test-button" onclick="loadTestOptimizedAPI()">
            High Load Test (100 requests)
          </button>
          <button class="cpu-test-button" onclick="cpuTestOptimizedAPI()">
            üî• CPU Intensive Test
          </button>
        </div>

        <!-- Scaled API Card -->
        <div class="api-card scaled-api">
          <div class="api-title">
            <span class="status-indicator" id="scaled-status"></span>
            üöÄ Scaled API
          </div>
          <div class="api-description">
            Multi-process cluster<br />
            8 worker processes<br />
            Shared Redis cache
          </div>
          <div class="api-metrics">
            <div class="metric-item">
              <span class="metric-label">Avg Response:</span>
              <span class="metric-value" id="scaled-response">~1ms</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Total Time:</span>
              <span class="metric-value" id="scaled-total-time">0s</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Throughput:</span>
              <span class="metric-value" id="scaled-throughput">0 req/s</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Requests Count:</span>
              <span class="metric-value" id="scaled-requests">0</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Cache Hit Rate:</span>
              <span class="metric-value" id="scaled-cache-rate">95%+</span>
            </div>
            <div class="metric-item">
              <span class="metric-label">Workers:</span>
              <span class="metric-value" id="scaled-workers">8</span>
            </div>
          </div>
          <button class="test-button" onclick="testScaledAPI()">
            Send 10 Requests
          </button>
          <button class="load-test-button" onclick="loadTestScaledAPI()">
            High Load Test (100 requests)
          </button>
          <button class="cpu-test-button" onclick="cpuTestScaledAPI()">
            üî• CPU Intensive Test
          </button>
        </div>
      </div>

      <!-- Loading Indicator -->
      <div class="loading" id="loading">
        <div class="spinner"></div>
        <span id="loadingText">Running test...</span>
      </div>

      <!-- Charts Section -->
      <div class="charts-section">
        <!-- Real-time Performance Gauge -->
        <div class="chart-card speedometer-card">
          <div class="chart-header">
            <div class="chart-title">Average Response Time</div>
            <div
              style="
                margin-top: 10px;
                font-size: 0.9rem;
                color: rgba(255, 255, 255, 0.8);
                text-align: center;
              "
            >
              Shows live performance during tests
            </div>
          </div>
          <div class="speedometer-container">
            <div class="speedometer-status-top">
              <div class="speed-status" id="speed-status">
                Monitoring Stopped
              </div>
            </div>
            <div class="speedometer">
              <div class="speedometer-gauge">
                <div class="speedometer-needle" id="speedometer-needle"></div>
                <div class="speedometer-center"></div>
              </div>
              <div class="speedometer-labels">
                <span class="speed-label" style="left: 10%">0ms</span>
                <span class="speed-label" style="left: 25%">25ms</span>
                <span class="speed-label" style="left: 50%">50ms</span>
                <span class="speed-label" style="left: 75%">100ms</span>
                <span class="speed-label" style="left: 90%">200ms+</span>
              </div>
              <div class="speedometer-display">
                <div class="speed-value" id="current-speed">0</div>
                <div class="speed-unit">ms avg</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Response Time Comparison Chart -->
        <div class="chart-card">
          <div class="chart-header">
            <div class="chart-title">Response Time Comparison</div>
            <div class="chart-controls">
              <button class="chart-test-button" onclick="runAllAPIs(10)">
                3 APIs (10 requests)
              </button>
              <button class="chart-test-button" onclick="runAllAPIs(100)">
                3 APIs (100 requests)
              </button>
              <button
                class="chart-test-button cpu-load-button"
                onclick="runCPUTest()"
              >
                üî• 3 APIs High CPU Load
              </button>
              <button class="clear-button" onclick="clearData()">üîÑ</button>
            </div>
          </div>
          <canvas id="responseComparisonChart"></canvas>
        </div>
      </div>
    </div>

    <script>
      // Replace all localhost URLs with current hostname
      document.addEventListener('DOMContentLoaded', function () {
        // This dynamic replacement is no longer needed since we use window.location.hostname
        console.log('Dashboard loaded for host:', window.location.hostname);
      });

      // Function to show project information
      function showProjectInfo() {
        const modal = document.createElement('div');
        modal.className = 'info-modal';
        modal.innerHTML = `
          <div class="info-modal-content">
            <div class="info-modal-header">
              <h3>About This Project</h3>
              <button class="info-modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="info-modal-body">
              <p><strong>Scalable API Performance Demonstration</strong></p>
              <p>This dashboard demonstrates three progressive API optimization techniques:</p>
              <ul>
                <li><strong>Basic API</strong> - Baseline performance with simulated database delays</li>
                <li><strong>Redis API</strong> - Caching optimization with ~1000x improvement</li>
                <li><strong>Cluster API</strong> - Multi-process architecture for CPU-intensive tasks</li>
              </ul>
              <p>Tech Stack: Node.js, TypeScript, Express.js, Redis, Docker</p>
              <div class="info-links">
                <a href="https://github.com/KseniiaRiabova/scalable-api#readme" target="_blank" class="info-link-button">
                  Read Documentation
                </a>
                <a href="https://github.com/KseniiaRiabova/scalable-api" target="_blank" class="info-link-button">
                  View Source Code
                </a>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(modal);

        // Add event listener to close modal when clicking outside
        modal.addEventListener('click', function (e) {
          if (e.target === modal) {
            closeModal();
          }
        });
      }

      function closeModal() {
        const modal = document.querySelector('.info-modal');
        if (modal) {
          modal.remove();
        }
      }

      // Chart configurations
      const responseChart = new Chart(
        document.getElementById('responseComparisonChart'),
        {
          type: 'bar',
          data: {
            labels: ['Basic API', 'Optimized API', 'Scaled API'],
            datasets: [
              {
                label: 'Average Response Time (ms)',
                data: [0, 0, 0], // Will be updated when tests run
                backgroundColor: ['#f44336', '#4CAF50', '#2196F3'],
                borderColor: ['#d32f2f', '#45a049', '#1976D2'],
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                type: 'logarithmic',
                beginAtZero: false,
                min: 0.1,
                title: {
                  display: true,
                  text: 'Response Time (ms) - Log Scale',
                },
                ticks: {
                  callback: function (value) {
                    if (value === 0.1) return '0.1';
                    if (value === 1) return '1';
                    if (value === 10) return '10';
                    if (value === 100) return '100';
                    if (value === 1000) return '1000';
                    return '';
                  },
                },
              },
            },
            plugins: {
              legend: {
                display: false,
              },
              title: {
                display: true,
                text: 'Click the buttons above to test each API!',
              },
            },
          },
        }
      );

      // Utility functions
      function setLoading(active, text = 'Running test...') {
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        loading.className = active ? 'loading active' : 'loading';
        loadingText.textContent = text;
      }

      function updateStatus(apiType, status) {
        const statusEl = document.getElementById(`${apiType}-status`);
        statusEl.className = `status-indicator ${status}`;
      }

      function updateChart(apiIndex, responseTime) {
        // Ensure minimum value for logarithmic scale
        const logValue = Math.max(responseTime, 0.1);
        responseChart.data.datasets[0].data[apiIndex] = logValue;
        responseChart.update();
      }

      function clearChartData() {
        // Reset all chart data
        responseChart.data.datasets[0].data = [0, 0, 0];
        responseChart.options.plugins.title.text =
          'Click the buttons above to test each API!';
        responseChart.update();

        // Reset all status indicators
        updateStatus('basic', 'status-offline');
        updateStatus('optimized', 'status-offline');
        updateStatus('scaled', 'status-offline');

        // Reset metrics in cards to default values
        document.getElementById('basic-response').textContent = '~1-5ms';
        document.getElementById('optimized-response').textContent = '~1ms';
        document.getElementById('scaled-response').textContent = '~1ms';
        document.getElementById('scaled-workers').textContent = '8';
      }

      // Detect current environment and set API URLs
      const currentPort = window.location.port || '80';
      // Automatically use current hostname (works for both localhost and VPS)
      // Configuration for API endpoints
      // Configuration for API endpoints
      const getApiConfig = () => {
        const currentHost = window.location.hostname;
        const protocol = window.location.protocol;

        // Check if we're running locally
        const isLocalhost =
          currentHost === 'localhost' || currentHost === '127.0.0.1';

        if (isLocalhost) {
          // Local development configuration
          return {
            basic: `${protocol}//${currentHost}:3002`,
            optimized: `${protocol}//${currentHost}:3000`,
            scaled: `${protocol}//${currentHost}:3001`,
          };
        } else {
          // Production configuration using nginx proxy
          return {
            basic: `${protocol}//${currentHost}/scalable-api/basic`,
            optimized: `${protocol}//${currentHost}/scalable-api/redis`,
            scaled: `${protocol}//${currentHost}/scalable-api/cluster`,
          };
        }
      };
      // Use the API configuration
      const API_URLS = getApiConfig();

      // Test functions
      async function testBasicAPI() {
        setLoading(true, 'Testing Basic API with 10 requests...');
        updateStatus('basic', 'status-testing');

        try {
          const numRequests = 10;
          const startTime = performance.now();

          // Send 10 requests to basic API (port 3002)
          const promises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.basic}/user`).then((r) => r.json())
          );

          await Promise.all(promises);
          const endTime = performance.now();

          const avgTime = (endTime - startTime) / numRequests;
          const totalTime = endTime - startTime;
          updateStatus('basic', 'status-online');
          updateChart(0, avgTime);

          // Update speedometer during test
          updateSpeedometerDuringTest('Basic API', avgTime);

          // Update all metrics in the card
          const throughput = (numRequests / (totalTime / 1000)).toFixed(1);
          document.getElementById(
            'basic-response'
          ).textContent = `${avgTime.toFixed(1)}ms`;
          document.getElementById('basic-total-time').textContent = `${(
            totalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'basic-throughput'
          ).textContent = `${throughput} req/s`;
          document.getElementById(
            'basic-requests'
          ).textContent = `${numRequests}`;
        } catch (error) {
          updateStatus('basic', 'status-offline');
        }

        // Reset test progress after a short delay
        setTimeout(() => {
          resetTestProgress();
        }, 2000);
        setLoading(false);
      }

      async function loadTestBasicAPI() {
        setLoading(
          true,
          'High Load Test: Testing Basic API with 100 requests...'
        );
        updateStatus('basic', 'status-testing');

        try {
          const numRequests = 100;
          const startTime = performance.now();

          // Send 100 concurrent requests to basic API (port 3002)
          const promises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.basic}/user`).then((r) => r.json())
          );

          await Promise.all(promises);
          const endTime = performance.now();

          const avgTime = (endTime - startTime) / numRequests;
          const totalTime = endTime - startTime;
          updateStatus('basic', 'status-online');
          updateChart(0, avgTime);

          // Update speedometer during load test
          updateSpeedometerDuringTest('Basic API (High Load)', avgTime);

          // Update all metrics in the card
          const throughput = (numRequests / (totalTime / 1000)).toFixed(1);
          document.getElementById(
            'basic-response'
          ).textContent = `${avgTime.toFixed(1)}ms`;
          document.getElementById('basic-total-time').textContent = `${(
            totalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'basic-throughput'
          ).textContent = `${throughput} req/s`;
          document.getElementById(
            'basic-requests'
          ).textContent = `${numRequests}`;
        } catch (error) {
          updateStatus('basic', 'status-offline');
        }

        // Reset test progress after a short delay
        setTimeout(() => {
          resetTestProgress();
        }, 2000);
        setLoading(false);
      }

      async function testOptimizedAPI() {
        setLoading(true, 'Testing Optimized API with 10 requests...');
        updateStatus('optimized', 'status-testing');

        try {
          const numRequests = 10;
          const startTime = performance.now();

          // Send 10 requests to optimized API (port 3000)
          const promises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.optimized}/user`).then((r) => r.json())
          );

          await Promise.all(promises);
          const endTime = performance.now();

          const avgTime = (endTime - startTime) / numRequests;
          const totalTime = endTime - startTime;
          updateStatus('optimized', 'status-online');
          updateChart(1, avgTime);

          // Update speedometer during test
          updateSpeedometerDuringTest('Optimized API', avgTime);

          // Update all metrics in the card
          const throughput = (numRequests / (totalTime / 1000)).toFixed(1);
          document.getElementById(
            'optimized-response'
          ).textContent = `${avgTime.toFixed(1)}ms`;
          document.getElementById('optimized-total-time').textContent = `${(
            totalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'optimized-throughput'
          ).textContent = `${throughput} req/s`;
          document.getElementById(
            'optimized-requests'
          ).textContent = `${numRequests}`;
        } catch (error) {
          updateStatus('optimized', 'status-offline');
        }

        // Reset test progress after a short delay
        setTimeout(() => {
          resetTestProgress();
        }, 2000);
        setLoading(false);
      }

      async function testScaledAPI() {
        setLoading(true, 'Testing Scaled API with 10 requests...');
        updateStatus('scaled', 'status-testing');

        try {
          const numRequests = 10;
          const startTime = performance.now();

          // Send 10 requests to cluster API (port 3001)
          const promises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.scaled}/user`).then((r) => r.json())
          );

          const results = await Promise.all(promises);
          const endTime = performance.now();

          const avgTime = (endTime - startTime) / numRequests;
          updateStatus('scaled', 'status-online');
          updateChart(2, avgTime);

          // Update speedometer during test
          updateSpeedometerDuringTest('Scaled API', avgTime);

          // Show which workers handled the requests
          const workers = [
            ...new Set(results.map((r) => r.worker).filter(Boolean)),
          ];
          const workerInfo =
            workers.length > 0 ? `\nWorkers used: ${workers.join(', ')}` : '';

          // Update all metrics in the card
          const totalTime = endTime - startTime;
          const throughput = (numRequests / (totalTime / 1000)).toFixed(1);
          document.getElementById(
            'scaled-response'
          ).textContent = `${avgTime.toFixed(1)}ms`;
          document.getElementById('scaled-total-time').textContent = `${(
            totalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'scaled-throughput'
          ).textContent = `${throughput} req/s`;
          document.getElementById(
            'scaled-requests'
          ).textContent = `${numRequests}`;
          document.getElementById(
            'scaled-workers'
          ).textContent = `${workers.length} active`;

          console.log('Scaled API test results:', {
            workers: workers,
            workersLength: workers.length,
            results: results,
          });
        } catch (error) {
          updateStatus('scaled', 'status-offline');
        }

        // Reset test progress after a short delay
        setTimeout(() => {
          resetTestProgress();
        }, 2000);
        setLoading(false);
      }

      async function loadTestOptimizedAPI() {
        setLoading(
          true,
          'High Load Test: Testing Optimized API with 100 requests...'
        );
        updateStatus('optimized', 'status-testing');

        try {
          const numRequests = 100;
          const startTime = performance.now();

          // Send 100 concurrent requests to optimized API (port 3000)
          const promises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.optimized}/user`).then((r) => r.json())
          );

          const results = await Promise.all(promises);
          const endTime = performance.now();

          const avgTime = (endTime - startTime) / numRequests;
          const totalTime = endTime - startTime;
          updateStatus('optimized', 'status-online');
          updateChart(1, avgTime);

          // Update all metrics in the card
          const throughput = (numRequests / (totalTime / 1000)).toFixed(1);
          document.getElementById(
            'optimized-response'
          ).textContent = `${avgTime.toFixed(1)}ms`;
          document.getElementById('optimized-total-time').textContent = `${(
            totalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'optimized-throughput'
          ).textContent = `${throughput} req/s`;
          document.getElementById(
            'optimized-requests'
          ).textContent = `${numRequests}`;
        } catch (error) {
          updateStatus('optimized', 'status-offline');
        }

        setLoading(false);
      }

      async function loadTestScaledAPI() {
        setLoading(
          true,
          'High Load Test: Testing Scaled API with 100 requests...'
        );
        updateStatus('scaled', 'status-testing');

        try {
          const numRequests = 100;
          const startTime = performance.now();

          // Send 100 concurrent requests to cluster API (port 3001)
          const promises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.scaled}/user`).then((r) => r.json())
          );

          const results = await Promise.all(promises);
          const endTime = performance.now();

          const avgTime = (endTime - startTime) / numRequests;
          const totalTime = endTime - startTime;
          updateStatus('scaled', 'status-online');
          updateChart(2, avgTime);

          // Show which workers handled the requests
          const workers = [
            ...new Set(results.map((r) => r.worker).filter(Boolean)),
          ];
          const workerInfo =
            workers.length > 0 ? `\nWorkers used: ${workers.join(', ')}` : '';

          // Update all metrics in the card
          const throughput = (numRequests / (totalTime / 1000)).toFixed(1);
          document.getElementById(
            'scaled-response'
          ).textContent = `${avgTime.toFixed(1)}ms`;
          document.getElementById('scaled-total-time').textContent = `${(
            totalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'scaled-throughput'
          ).textContent = `${throughput} req/s`;
          document.getElementById(
            'scaled-requests'
          ).textContent = `${numRequests}`;
          document.getElementById(
            'scaled-workers'
          ).textContent = `${workers.length} active`;

          console.log('Scaled API High Load Test results:', {
            workers: workers,
            workersLength: workers.length,
            results: results.length,
            totalTime: totalTime,
            avgTime: avgTime,
          });
        } catch (error) {
          updateStatus('scaled', 'status-offline');
        }

        setLoading(false);
      }

      // CPU Intensive Tests
      async function cpuTestBasicAPI() {
        setLoading(
          true,
          'üî• CPU Test: Testing Basic API with heavy CPU load...'
        );
        updateStatus('basic', 'status-testing');

        try {
          const numRequests = 20;
          const startTime = performance.now();

          // Send concurrent requests for fair comparison
          const promises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.basic}/cpu-intensive`).then((r) => r.json())
          );

          const results = await Promise.all(promises);
          const endTime = performance.now();
          const totalTime = endTime - startTime;
          // Calculate actual concurrent performance (total time / requests)
          const avgTime = totalTime / numRequests;

          updateStatus('basic', 'status-online');
          updateChart(0, avgTime);

          // Update all metrics
          const throughput = (numRequests / (totalTime / 1000)).toFixed(1);
          document.getElementById(
            'basic-response'
          ).textContent = `${avgTime.toFixed(1)}ms`;
          document.getElementById('basic-total-time').textContent = `${(
            totalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'basic-throughput'
          ).textContent = `${throughput} req/s`;
          document.getElementById(
            'basic-requests'
          ).textContent = `${numRequests}`;
        } catch (error) {
          updateStatus('basic', 'status-offline');
        }

        setLoading(false);
      }

      async function cpuTestOptimizedAPI() {
        setLoading(
          true,
          'üî• CPU Test: Testing Redis API with heavy CPU load...'
        );
        updateStatus('optimized', 'status-testing');

        try {
          const numRequests = 20;
          const startTime = performance.now();

          // Send concurrent requests for fair comparison (no rate limits)
          const promises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.optimized}/cpu-intensive`).then((r) => r.json())
          );

          const results = await Promise.all(promises);
          const endTime = performance.now();
          const totalTime = endTime - startTime;
          // Calculate actual concurrent performance (total time / requests)
          const avgTime = totalTime / numRequests;

          updateStatus('optimized', 'status-online');
          updateChart(1, avgTime);

          // Update all metrics
          const throughput = (numRequests / (totalTime / 1000)).toFixed(1);
          document.getElementById(
            'optimized-response'
          ).textContent = `${avgTime.toFixed(1)}ms`;
          document.getElementById('optimized-total-time').textContent = `${(
            totalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'optimized-throughput'
          ).textContent = `${throughput} req/s`;
          document.getElementById(
            'optimized-requests'
          ).textContent = `${numRequests}`;
        } catch (error) {
          updateStatus('optimized', 'status-offline');
        }

        setLoading(false);
      }

      async function cpuTestScaledAPI() {
        setLoading(
          true,
          'üî• CPU Test: Testing Cluster API with heavy CPU load...'
        );
        updateStatus('scaled', 'status-testing');

        try {
          const numRequests = 20;
          const startTime = performance.now();

          // Send concurrent requests to demonstrate clustering
          const promises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.scaled}/cpu-intensive`).then((r) => r.json())
          );

          const results = await Promise.all(promises);
          const endTime = performance.now();

          const totalTime = endTime - startTime;
          // Calculate actual concurrent performance (total time / requests)
          const avgTime = totalTime / numRequests;

          // Show worker distribution
          const workers = [
            ...new Set(results.map((r) => r.worker).filter(Boolean)),
          ];

          updateStatus('scaled', 'status-online');
          updateChart(2, avgTime);

          // Update all metrics
          const throughput = (numRequests / (totalTime / 1000)).toFixed(1);
          document.getElementById(
            'scaled-response'
          ).textContent = `${avgTime.toFixed(1)}ms`;
          document.getElementById('scaled-total-time').textContent = `${(
            totalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'scaled-throughput'
          ).textContent = `${throughput} req/s`;
          document.getElementById(
            'scaled-requests'
          ).textContent = `${numRequests}`;
          document.getElementById(
            'scaled-workers'
          ).textContent = `${workers.length} active`;
        } catch (error) {
          updateStatus('scaled', 'status-offline');
        }

        setLoading(false);
      }

      // Chart control functions
      async function runAllAPIs(numRequests = 10) {
        setLoading(
          true,
          `Running all APIs for comparison (${numRequests} requests)...`
        );

        const responses = {};

        try {
          // Test Basic API
          updateStatus('basic', 'status-testing');
          const basicStart = performance.now();

          const basicPromises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.basic}/user`).then((r) => r.json())
          );
          await Promise.all(basicPromises);

          const basicEnd = performance.now();
          responses.basic = (basicEnd - basicStart) / numRequests;
          updateStatus('basic', 'status-online');

          // Update speedometer for Basic API
          updateSpeedometerDuringTest('Basic API (Batch)', responses.basic);

          // Test Redis API
          updateStatus('optimized', 'status-testing');
          const redisStart = performance.now();

          const redisPromises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.optimized}/user`).then((r) => r.json())
          );
          await Promise.all(redisPromises);

          const redisEnd = performance.now();
          responses.redis = (redisEnd - redisStart) / numRequests;
          updateStatus('optimized', 'status-online');

          // Update speedometer for Redis API
          updateSpeedometerDuringTest('Optimized API (Batch)', responses.redis);

          // Test Cluster API
          updateStatus('scaled', 'status-testing');
          const clusterStart = performance.now();

          const clusterPromises = Array.from({ length: numRequests }, () =>
            fetch(`${API_URLS.scaled}/user`).then((r) => r.json())
          );
          await Promise.all(clusterPromises);

          const clusterEnd = performance.now();
          responses.cluster = (clusterEnd - clusterStart) / numRequests;
          updateStatus('scaled', 'status-online');

          // Update speedometer for Cluster API and show overall average
          updateSpeedometerDuringTest('Scaled API (Batch)', responses.cluster);

          // After all tests, show overall average
          setTimeout(() => {
            const overallAvg =
              (responses.basic + responses.redis + responses.cluster) / 3;
            updateSpeedometerDuringTest('All APIs Average', overallAvg);
          }, 1000);

          // Update chart
          updateChart(0, responses.basic);
          updateChart(1, responses.redis);
          updateChart(2, responses.cluster);

          // Update displayed metrics
          document.getElementById(
            'basic-response'
          ).textContent = `${responses.basic.toFixed(1)}ms`;
          document.getElementById(
            'optimized-response'
          ).textContent = `${responses.redis.toFixed(1)}ms`;
          document.getElementById(
            'scaled-response'
          ).textContent = `${responses.cluster.toFixed(1)}ms`;
        } catch (error) {
          console.error('Error running all APIs:', error);
        }

        // Reset test progress after completion
        setTimeout(() => {
          resetTestProgress();
        }, 3000);
        setLoading(false);
      }

      async function runCPUTest() {
        setLoading(
          true,
          'üî• Running CPU-intensive test on all APIs (20 concurrent requests each)...'
        );

        const responses = {};

        try {
          // Test Basic API CPU endpoint
          updateStatus('basic', 'status-testing');
          const basicStart = performance.now();
          const basicPromises = Array.from({ length: 20 }, () =>
            fetch(`${API_URLS.basic}/cpu-intensive`).then((r) => r.json())
          );
          const basicResults = await Promise.all(basicPromises);
          const basicEnd = performance.now();
          const basicTime = (basicEnd - basicStart) / 20; // Average per request
          updateStatus('basic', 'status-online');
          updateChart(0, basicTime);
          responses.basic = basicTime;

          // Update Basic API metrics
          const basicTotalTime = basicEnd - basicStart;
          const basicThroughput = (20 / (basicTotalTime / 1000)).toFixed(1);
          document.getElementById(
            'basic-response'
          ).textContent = `${basicTime.toFixed(1)}ms`;
          document.getElementById('basic-total-time').textContent = `${(
            basicTotalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'basic-throughput'
          ).textContent = `${basicThroughput} req/s`;
          document.getElementById('basic-requests').textContent = '20';

          // Test Redis API CPU endpoint
          updateStatus('optimized', 'status-testing');
          const redisStart = performance.now();
          const redisPromises = Array.from({ length: 20 }, () =>
            fetch(`${API_URLS.optimized}/cpu-intensive`).then((r) => r.json())
          );
          const redisResults = await Promise.all(redisPromises);
          const redisEnd = performance.now();
          const redisTime = (redisEnd - redisStart) / 20; // Average per request
          updateStatus('optimized', 'status-online');
          updateChart(1, redisTime);
          responses.optimized = redisTime;

          // Update Redis API metrics
          const redisTotalTime = redisEnd - redisStart;
          const redisThroughput = (20 / (redisTotalTime / 1000)).toFixed(1);
          document.getElementById(
            'optimized-response'
          ).textContent = `${redisTime.toFixed(1)}ms`;
          document.getElementById('optimized-total-time').textContent = `${(
            redisTotalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'optimized-throughput'
          ).textContent = `${redisThroughput} req/s`;
          document.getElementById('optimized-requests').textContent = '20';

          // Test Cluster API CPU endpoint
          updateStatus('scaled', 'status-testing');
          const clusterStart = performance.now();
          const clusterPromises = Array.from({ length: 20 }, () =>
            fetch(`${API_URLS.scaled}/cpu-intensive`).then((r) => r.json())
          );
          const clusterResults = await Promise.all(clusterPromises);
          const clusterEnd = performance.now();
          const clusterTime = (clusterEnd - clusterStart) / 20; // Average per request
          updateStatus('scaled', 'status-online');
          updateChart(2, clusterTime);
          responses.scaled = clusterTime;

          // Update Cluster API metrics
          const clusterTotalTime = clusterEnd - clusterStart;
          const clusterThroughput = (20 / (clusterTotalTime / 1000)).toFixed(1);
          const clusterWorkers = [
            ...new Set(clusterResults.map((r) => r.worker).filter(Boolean)),
          ];
          document.getElementById(
            'scaled-response'
          ).textContent = `${clusterTime.toFixed(1)}ms`;
          document.getElementById('scaled-total-time').textContent = `${(
            clusterTotalTime / 1000
          ).toFixed(1)}s`;
          document.getElementById(
            'scaled-throughput'
          ).textContent = `${clusterThroughput} req/s`;
          document.getElementById('scaled-requests').textContent = '20';
          document.getElementById(
            'scaled-workers'
          ).textContent = `${clusterWorkers.length} active`;

          // Update chart title to show this was a CPU test
          responseChart.options.plugins.title.text =
            'üî• CPU-Intensive Test Results (20 concurrent requests each)';
          responseChart.update();

          console.log('üî• CPU Test Results:');
          console.log(
            `Basic API: ${basicTime.toFixed(1)}ms avg (${basicTotalTime.toFixed(
              1
            )}ms total)`
          );
          console.log(
            `Redis API: ${redisTime.toFixed(1)}ms avg (${redisTotalTime.toFixed(
              1
            )}ms total)`
          );
          console.log(
            `Cluster API: ${clusterTime.toFixed(
              1
            )}ms avg (${clusterTotalTime.toFixed(1)}ms total)`
          );
          console.log(`Cluster workers used: ${clusterWorkers.join(', ')}`);
        } catch (error) {
          console.error('Error running CPU test:', error);
        }

        setLoading(false);
      }

      function clearData() {
        // Clear main chart
        clearChartData();
      }

      // Real-time speedometer functionality
      let testInProgress = false;
      let currentTestResults = [];
      const APIs = [
        { url: `${API_URLS.basic}/user`, name: 'Basic' },
        { url: `${API_URLS.optimized}/user`, name: 'Optimized' },
        { url: `${API_URLS.scaled}/user`, name: 'Scaled' },
      ];

      function updateSpeedometerNeedle(value, testName = null) {
        const needle = document.getElementById('speedometer-needle');
        const speedValue = document.getElementById('current-speed');
        const statusElement = document.getElementById('speed-status');

        // Clamp value between 0 and 200ms for display
        const clampedValue = Math.min(value, 200);

        // Convert to angle (0-288 degrees, leaving 72 degrees gap at bottom)
        const angle = (clampedValue / 200) * 288;

        needle.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
        speedValue.textContent = value.toFixed(1);

        // Update status text based on context
        if (testInProgress && testName) {
          statusElement.textContent = `Testing ${testName}...`;
          statusElement.style.color = '#ffffff';
          statusElement.style.fontWeight = 'bold';
        } else {
          statusElement.textContent = 'Shows live performance during tests';
          statusElement.style.color = '#ffffff';
          statusElement.style.fontWeight = 'normal';
        }

        // Update color based on performance
        if (value < 10) {
          speedValue.style.color = '#4caf50';
        } else if (value < 25) {
          speedValue.style.color = '#ffeb3b';
        } else if (value < 50) {
          speedValue.style.color = '#ff8a50';
        } else {
          speedValue.style.color = '#f44336';
        }
      }

      // Function to update speedometer during tests
      function updateSpeedometerDuringTest(testName, avgResponseTime) {
        testInProgress = true;
        updateSpeedometerNeedle(avgResponseTime, testName);

        // Add to current test results for averaging
        currentTestResults.push({
          test: testName,
          time: avgResponseTime,
          timestamp: Date.now(),
        });

        // Keep only recent results (last 10 results)
        if (currentTestResults.length > 10) {
          currentTestResults = currentTestResults.slice(-10);
        }
      }

      // Function to calculate overall average from recent tests
      function getRecentTestAverage() {
        if (currentTestResults.length === 0) return 0;
        const sum = currentTestResults.reduce(
          (acc, result) => acc + result.time,
          0
        );
        return sum / currentTestResults.length;
      }

      // Function to reset test progress
      function resetTestProgress() {
        testInProgress = false;
        document.getElementById('speed-status').textContent =
          'Shows live performance during tests';
        document.getElementById('speed-status').style.color = '#ffffff';
        document.getElementById('speed-status').style.fontWeight = 'normal';
      }

      // Initialize
      resetTestProgress(); // Set default speedometer message
      updateStatus('basic', 'status-offline');
      updateStatus('optimized', 'status-offline');
      updateStatus('scaled', 'status-offline');
    </script>
  </body>
</html>
